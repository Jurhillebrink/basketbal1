{
    "collab_server" : "",
    "contents" : "#\n# This is the server logic of a Shiny web application. You can run the\n# application by clicking 'Run App' above.\n#\n# Find out more about building applications with Shiny here:\n#\n#    http://shiny.rstudio.com/\n#\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(shinydashboard)\nlibrary(ggplot2)\nlibrary(openssl)\nlibrary(shinyjs) #to hide side bar\nlibrary(grid) # for rastergrob, to set court as background of plot\nlibrary(plyr)\n\nrequire(\"DT\")\n\nsource(\"./global.R\")\n\nshinyServer(function(input, output, session) {\n  #On app start\n  observe({\n    getShotResults()\n    #Render the UI\n    renderAdmin()\n    renderPublicEvent()\n    renderHeatMap()\n    #renderPlayerEvent()\n    renderLastEvent()\n    renderPlayerInfo()\n    renderHeatmap()\n    renderAnalyses()\n  })\n  \n  #Method to render after logging in\n  loginRender <- function(){\n    renderPlayerInfo()\n    renderLastEvent()\n    renderHeatmap()\n    renderAnalyses()\n  }\n  \n  values <- reactiveValues(authenticated = FALSE)\n  \n  # Return the UI for a modal dialog with data selection input. If 'failed'\n  # is TRUE, then display a message that the previous value was invalid.\n  dataModal <- function(failed = FALSE) {\n    modalDialog(\n      textInput(\"uiUsername\", \"Username:\"),\n      passwordInput(\"uiPassword\", \"Password:\"),\n      textOutput('warning'),\n      tags$head(tags$style(\"#warning{color: red;}\")),\n      footer = tagList(actionButton(\"ok\", \"Login\"))\n    )\n  }\n  \n  # Show modal when button is clicked.\n  # This `observe` is suspended only whith right user credential\n  obs1 <- observe({\n    showModal(dataModal())\n  })\n  \n  # When OK button is pressed, attempt to authenticate. If successful,\n  # remove the modal.\n  obs2 <- observe({\n    req(input$ok)\n    isolate({\n      username <- input$uiUsername\n      password <- input$uiPassword\n    })\n    #Encrypt the password\n    password = toString(sha256(password, key = NULL))\n\n    query <- paste0(\n      \"exec LOGIN \n        @USERNAME = ?email, \n        @PASSWORD = ?pass\"\n    )\n    \n    sql <- sqlInterpolate(conn, query, email = username, pass = password)\n    rs <- dbGetQuery(conn, sql)\n    \n    #If result is 1 row long the user is authenticated\n    if (nrow(rs) == 1) {\n      print(\"Logged In\")\n      currentUser <<- rs\n      getShotResults()\n      Logged <<- TRUE\n      values$authenticated <- TRUE\n      obs1$suspend()\n      removeModal()\n      \n      getShotResults()\n      \n      #no more warning for wrong credentials\n      output$warning <-\n        renderText({\n          paste(\"\")\n        })\n      \n      checkData()\n      loginRender()\n      \n    } else {\n      #User not authenticated\n      values$authenticated <- FALSE\n      print(\"Wrong Credentials\")\n      output$warning <-\n        renderText({\n          paste(\"Credentials are wrong\")\n        })\n    }\n    \n  })\n  \n  output$teammates <- renderDataTable(teammates)\n  \n  \n  output$dataInfo <- renderPrint({\n    if (values$authenticated)\n      \"OK!!!!!\"\n    else\n      \"You are NOT authenticated\"\n  })\n  \n  ################################################################################\n  \n  #Buttons for plus minus\n  observeEvent(input$total_minus, {\n    new <- input$total - 1\n    updateNumericInput(session, \"total\", value = new)\n  })\n  \n  observeEvent(input$total_plus, {\n    new <- input$total + 1\n    updateNumericInput(session, \"total\", value = new)\n  })\n  \n  observeEvent(input$succeed_minus, {\n    new <- input$succeed - 1\n    updateNumericInput(session, \"succeed\", value = new)\n  })\n  \n  observeEvent(input$succeed_plus, {\n    new <- input$succeed + 1\n    updateNumericInput(session, \"succeed\", value = new)\n  })\n  \n  ################################################################################\n  #Modaldialog for the confirm input dialog.\n  \n  confirminputmodal <- modalDialog(\n      tags$h2(\"Please make sure your values are correct!\"),\n      tags$h3(\"Name\"),\n      tags$b(tags$h4(textOutput('confirmName'))),\n      tags$head(tags$style(\"#confirmName{color: #009900;}\")),\n      tags$h3(\"Type\"),\n      tags$b(tags$h4(textOutput('confirmType'))),\n      tags$head(tags$style(\"#confirmType{color: #009900;}\")),\n      tags$h3(\"Score\"),\n      tags$b(tags$h4(textOutput('confirmScore'))),\n      tags$head(tags$style(\"#confirmScore{color: #009900;}\")),\n      tags$h3(\"Position\"),\n      tags$b(tags$h4(textOutput('confirmPosition'))),\n      tags$head(tags$style(\"#confirmPosition{color: #009900;}\")),\n      footer = tagList(\n        actionButton(\"cancelConfirm\", \"Cancel\"),\n        actionButton(\"confirmValues\", \"Confirm, Next player\")\n      )\n    )\n  \n  #Add the values to the modal dialog\n  confirminputrender <- function(){\n    titles <- c(\"Free throw\",\"Catch & Shoot\", \"From dribble\")\n    values <- c(\"free_throw\",\"catch_throw\",\"dribble\")\n    df <- data.frame(x = values,\n    y = titles)\n    \n    rown <- which(df$x == input$typeselector)\n    \n    titleName <- titles[rown]\n    \n    if(input$typeselector == \"free_throw\"){\n      inputpositiondialog <- 0;\n    }else{\n      inputpositiondialog <- input$sliderPosition;\n    }\n    \n    output$confirmName <- renderText({ paste(allPlayers[allPlayers$accountid == input$radio,]$firstname,allPlayers[allPlayers$accountid == input$radio,]$lastname, sep=\" \" ) })\n    output$confirmType <- renderText({ paste(titleName) })\n    output$confirmScore <- renderText({ paste(input$succeed, input$total, sep=\"/\") })\n    output$confirmPosition <- renderText({ paste(inputpositiondialog) })\n  }\n  \n  #On confirm shot input.\n  observeEvent(input$insertShotbtn, {\n    if(input$succeed <= input$total){\n      \n      confirminputrender()\n      \n      showModal(confirminputmodal)\n    }else {\n      showModal(\n        modalDialog(\n          title = \"Invalid data.\",\n          \"Succeeded shots exceeded total shots.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n    }\n    \n  })\n  \n  #Cancel the input.\n  observeEvent(input$cancelConfirm, {\n    removeModal()\n  })\n  \n  #Call the stored procedure to input the actual data in the database.\n  observeEvent(input$confirmValues, {\n    if(input$typeselector == \"free_throw\"){\n      inputposition <- 0;\n    }else{\n      inputposition <- input$sliderPosition;\n    }\n    \n    query <- paste0(\n      \"exec INSERTSHOTVALUES \n      @USERID = ?userid,\n      @EVENTID = ?eventid,\n      @SUCCEED = ?succeed,\n      @TOTAL = ?total,\n      @POSITION = ?position,\n      @TYPE = ?type\"\n    )\n    sql <- sqlInterpolate(conn, query, \n                          userid = input$radio, \n                          eventid = latestEventid,\n                          succeed = input$succeed,\n                          total = input$total,\n                          position = inputposition,\n                          type = input$typeselector)\n    \n    dbSendUpdate(conn, sql)\n    \n    showModal(\n      modalDialog(\n        title = \"Values added\",\n        \"The values were successfully added to the system.\",\n        easyClose = TRUE,\n        footer = NULL\n      )\n    )\n  })\n  \n  #On logout button click\n  observeEvent(input$logoutBtn, {\n    #Check if user is in an event\n    if(inEvent == FALSE){\n      #Clear the menu and remove auth values, also reload the session.\n      output$menu <- renderMenu({\n        sidebarMenu(menuItem(\"\"))\n      })\n      \n      values$authenticated <- FALSE\n      obs1 <- observe({\n        showModal(dataModal())\n      })\n      session$reload()\n    } else {\n      #Show dialog when in a training.\n      showModal(\n        modalDialog(\n          title = \"Can't logout.\",\n          \"Can't logout during a training session.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n    }\n    \n  })\n  \n\n  #to the next screen of test input\n  observeEvent(input$switchtab, {\n    if (!is.null(input$playersInEvent)) {\n      query <- paste0(\n        \"exec STARTEVENT\"\n      )\n      dbSendUpdate(conn, query)\n      \n      ###############################\n      \n      query <- paste0(\n        \"exec GETLASTEVENT\"\n      )\n      rsevent <- dbGetQuery(conn, query)\n      \n      latestEventid <<- rsevent$eventid\n      print(latestEventid)\n      \n      playersInEvent <<- input$playersInEvent\n      for (player in input$playersInEvent){\n        query <- paste0(\n          \"exec CREATEUSEREVENT \n          @ACCOUNTID = ?accountid,\n          @EVENTID = ?eventid\"\n        )\n        sql <- sqlInterpolate(conn, query, \n                              accountid = player, \n                              eventid = latestEventid)\n        dbSendUpdate(conn, sql)\n        \n        print(paste(\"insert\", player, latestEventid ,sep=\" \"))\n      }\n      \n      lastnames <-\n        allPlayers[allPlayers$accountid %in% playersInEvent, ]$fullname\n      accountids <-\n        allPlayers[allPlayers$accountid %in% playersInEvent, ]$accountid\n      species <- data.frame(lastnames, accountids)\n      eventPlayersChoices <-\n        setNames(as.numeric(species$accountids), species$lastnames)\n      updateRadioButtons(session, 'radio', choices = eventPlayersChoices)\n      \n      inEvent <<- TRUE# needed to prevent loggin out during event\n      \n      # change the menu during a session.\n      # because there should not be able to switch pages\n      output$menu <- renderMenu({\n        sidebarMenu(hidden(\n          menuItem(\n            \"InvoerSchoten\",\n            tabName = \"InvoerSchoten2\",\n            icon = icon(\"plus-circle\"),\n            selected = TRUE\n          )\n        ),\n        \"Menu not available during a training.\")\n      })\n      # hide menu\n      shinyjs::addClass(selector = \"body\", class = \"sidebar-collapse\")\n    } else {\n      showModal(\n        modalDialog(\n          title = \"Invalid data.\",\n          \"No players were selected\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n    }\n  })\n  \n  #Modal to end the session\n  endSessionModal <- modalDialog(\n    passwordInput(\"eventPassword\", \"Password:\"),\n    textOutput('warningEvent'),\n    tags$head(tags$style(\"#warningEvent{color: red;}\")),\n    footer = tagList(\n      actionButton(\"cancelEnd\", \"Cancel\"),\n      actionButton(\"endEvent\", \"End\")\n    )\n  )\n  \n  #to end a session\n  observeEvent(input$closeTestEvent, {\n    showModal(endSessionModal)\n  })\n  #Hide the modal\n  observeEvent(input$cancelEnd, {\n    removeModal()\n  })\n  \n  # refresh the player list in a event\n  observeEvent(input$refreshPlayers, {\n    getAllPlayers()\n    print(paste(\"latest event: \", latestEventid))\n    query <- paste0(\n      \"exec GETPLAYERSINEVENT \n      @EVENTID = ?eventid\"\n    )\n    \n    sql <- sqlInterpolate(conn, query,\n                          eventid = latestEventid)\n    \n    rs <- dbGetQuery(conn, sql)\n\n    playersInEvent <<- rs$accountid\n    print(rs)\n    renderPublicEvent()\n    #session$reload()\n    #shinyjs::reset(\"playerSelect\")\n  })\n  \n  # to end a event\n  observeEvent(input$endEvent, {\n    #check for pass of the trainer\n    isolate({\n      password <- input$eventPassword\n    })\n\n    password = toString(sha256(password, key = NULL))\n    query <- paste0(\n      \"exec LOGIN \n      @USERNAME = ?email, \n      @PASSWORD = ?pass\"\n    )\n    sql <- sqlInterpolate(conn, query, \n                          email = currentUser$email, \n                          pass = password)\n    rs <- dbGetQuery(conn, sql)\n    \n    if (nrow(rs) == 1) {\n      endEvent()\n      getShotResults()\n    } else {\n      print(\"Wrong Password\")\n      output$warningEvent <-\n        renderText({\n          paste(\"Wrong password\")\n        })\n    }\n    \n  })\n  \n  #Ending event\n  endEvent <- function() {\n    inEvent <<- FALSE\n    query <- paste0(\n      \"exec ENDEVENT \n      @EVENTID = ?eventid\"\n    )\n    sql <- sqlInterpolate(conn, query,\n                          eventid = latestEventid)\n    dbSendUpdate(conn, sql)\n\n    #Render the menu again, but select the last event tab.\n    output$menu <- renderMenu({\n      sidebarMenu(\n        menuItem(\n          \"InvoerSchoten\",\n          tabName = \"InvoerSchoten1\",\n          icon = icon(\"plus-circle\")\n        ),\n        menuItem(\n          \"Analyse players\",\n          icon = icon(\"bar-chart\"),\n          menuSubItem(\n            \"Last event\",\n            tabName = \"lastEventCoach\",\n            icon = icon(\"dribbble\"),\n            selected = TRUE # direct to last event page\n          ),\n          menuSubItem(\n            \"Shot results\",\n            tabName = \"shotAnalyse\",\n            icon = icon(\"bar-chart\")\n          ),\n          menuSubItem(\n            \"Shot results 2\",\n            tabName = \"shotAnalyse2\",\n            icon = icon(\"line-chart\")\n          )\n        )\n      )\n    })\n    # show menu\n    shinyjs::removeClass(selector = \"body\", class = \"sidebar-collapse\")\n    removeModal()\n  }\n  \n  ##############################################################\n  \n  #Insert the team\n  observeEvent(input$insertTeam, {\n    #Check if the teamcode is not empty\n    if (input$teamcode != \"\") {\n      \n      isolate({\n        teamcode <- input$teamcode\n      })\n      \n      query <- paste0(\n        \"exec CREATETEAM \n        @TEAMCODE = ?code\"\n      )\n      sql <- sqlInterpolate(conn, query, \n                            code = teamcode)\n      dbSendUpdate(conn, sql)\n      \n      showModal(\n        modalDialog(\n          title = \"Team added.\",\n          \"The team was successfully added.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n      \n      renderAdmin()\n    } else {\n      showModal(\n        modalDialog(\n          title = \"Invalid data.\",\n          \"Teamcode was empty.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n    }\n  })\n  \n  #Insert the users\n  observeEvent(input$insertUser, {\n    isolate({\n      email     <- input$useremail\n      password  <- input$userpassword\n      role      <- input$userrole\n      firstname <- input$userfirstname\n      lastname  <- input$userlastname\n      birthday  <- input$userbirthday\n      phone     <- input$userphonenumber\n      teamid    <- as.numeric(input$userteam)\n    })\n    \n    password = toString(sha256(password, key = NULL))\n    birthday = toString(birthday)\n    teamid   = as.numeric(teamid)\n    \n    print(password)\n    \n    if (input$useremail != \"\") {\n      query <- paste0(\n        \"exec CREATEUSER\n          @EMAIL = ?email,\n          @PASSWORD = ?pass,\n          @ROLE = ?role,\n          @FIRSTNAME = ?fname,\n          @LASTNAME = ?lname,\n          @BIRTHDAY = ?bday,\n          @PHONE = ?phone,\n          @TEAMID = ?teamid\"\n      )\n      print(query)\n      sql <- sqlInterpolate(conn, query, \n                            email = email, \n                            pass = password, \n                            role = role, \n                            fname= firstname, \n                            lname = lastname,\n                            bday= birthday,\n                            phone = phone,\n                            teamid = teamid)\n      dbSendUpdate(conn, sql)\n      \n      showModal(\n        modalDialog(\n          title = \"Account created.\",\n          \"The user was added to the system.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n      renderAdmin()\n    } else {\n      showModal(\n        modalDialog(\n          title = \"Invalid data.\",\n          \"E-mail was empty.\",\n          easyClose = TRUE,\n          footer = NULL\n        )\n      )\n    }\n    \n  })\n  \n  \n  ##############################################################\n  \n  checkData <- function() {\n    print(currentUser$role)\n    query <- paste0(\n      \"exec GETPLAYER \n      @TEAMID = ?teamid\"\n    )\n    sql <- sqlInterpolate(conn, query, teamid = currentUser$teamid)\n    rs <- dbGetQuery(conn, sql)\n    teammates <<- rs\n    \n    output$menu <- renderMenu({\n      if (currentUser$role == \"a\") {\n        #User is an admin\n        #Render the sidebar \n        sidebarMenu(id = \"tabs\",\n                    menuItem(\n                      \"Admin\",\n                      tabName = \"admin\",\n                      icon = icon(\"database\"),\n                      selected = TRUE\n                    ))\n      } else if (currentUser$role == \"c\") {\n        #User is a coach/trainer\n        #Render the sidebar \n        sidebarMenu(\n          menuItem(\n            \"Start Training\",\n            tabName = \"InvoerSchoten1\",\n            icon = icon(\"plus-circle\"),\n            selected = TRUE\n          ),\n          menuItem(\n            \"Analyse\",\n            icon = icon(\"bar-chart\"),\n            menuSubItem(\n              \"Last event\",\n              tabName = \"lastEventCoach\",\n              icon = icon(\"dribbble\")\n            ),\n            menuSubItem(\n              \"Shot results\",\n              tabName = \"shotAnalyse\",\n              icon = icon(\"bar-chart\")\n            ),\n            menuSubItem(\n              \"Shot results 2\",\n              tabName = \"shotAnalyse2\",\n              icon = icon(\"line-chart\")\n            )\n          )\n        )\n      } else if (currentUser$role == \"p\") {\n        #User is a player\n        #Get the events of the current user.\n        eventsOfPlayer     <<-\n          rsShotResult[currentUser$accountid == rsShotResult$accountid, ]\n        #Get all starttimes and format them\n        eventsOfPlayer$starttime <- as.POSIXct(strptime(eventsOfPlayer$starttime, \"%Y-%m-%d %H:%M:%S\"))\n        #order the events of the user by date\n        eventSubset <<- eventsOfPlayer[order(eventsOfPlayer$starttime, decreasing = FALSE),]\n        #Set the latest event\n        latestEvent        <<-\n          max(rsShotResult[currentUser$accountid == rsShotResult$accountid & rsShotResult$value != 0, ]$eventid, na.rm = TRUE)\n        #Render the sidebar \n        sidebarMenu(\n          id = \"tabs\",\n          menuItem(\n            \"Home\",\n            tabName = \"homePlayer\",\n            icon = icon(\"home\"),\n            selected = TRUE\n          ),\n          menuItem(\"Analysis\",\n                   icon = icon(\"bar-chart\"),\n                   menuSubItem(\n                     \"Heatmap\",\n                     tabName = \"heatMapPlayer\",\n                     icon = icon(\"thermometer-3\")\n                   )      \n          )#,\n          #menuItem(\n          #  \"Events\",\n          #  tabName = \"playerEvent\",\n          #  icon = icon(\"plus-circle\")\n          #)\n        )\n      }\n    })\n    \n    query <- paste0(\n      \"exec GETPLAYERLIST\"\n    )\n    sql <- sqlInterpolate(conn, query)\n    rs <- dbGetQuery(conn, sql)\n    \n    lastnames <- paste(rs$firstname, ' ' , rs$lastname)\n    accountids <- rs$accountid\n    species <- data.frame(lastnames, accountids)\n    choicesSpecies <-\n      setNames(as.numeric(species$accountids), species$lastnames)\n    \n    updateRadioButtons(session, 'radio', choices = choicesSpecies)\n  }\n  \n  #Render the player info\n  renderLastEvent <- function(){\n    # get the id of the last event\n    query <- paste0(\n      \"exec GETLASTEVENT\"\n    )\n    sql <- sqlInterpolate(conn, query)\n    latestEvent <- dbGetQuery(conn, sql)$eventid\n    \n    #latestEvent <- 401 #### REMOVE THIS LATER!!!!!!!! # this is done because there only is 1 legit event right now\n    \n    eventData <- rsShotResult[rsShotResult$eventid == latestEvent,] # select dtata of last event\n    \n    # render the page\n    output$last_event_coach <- renderUI({\n      lastEventLayout(eventData, currentUser)\n    })\n    \n    # render the player specific plot\n    output$last_event_per_player <- renderPlot({\n      eventDataSelectedPlayer <- eventData[eventData$fullname == input$select_player_last_event, ] # filter by player\n      # combine on position and type\n      eventDataSelectedPlayer <- with(eventDataSelectedPlayer,\n                                     aggregate(\n                                       list(\n                                         totalTaken = as.integer(value2),\n                                         totalMade = as.integer(value)\n                                       ),\n                                       list(\n                                         accountid = accountid,\n                                         fullname = fullname,\n                                         position = value3,\n                                         type = value4\n                                       ),\n                                       sum\n                                     ))\n      #calc %\n      eventDataSelectedPlayer$percentage <- ((eventDataSelectedPlayer$totalMade/eventDataSelectedPlayer$totalTaken)*100)\n      \n      #make plot\n      ggplot(eventDataSelectedPlayer,\n          aes(x = position,\n            y = percentage,\n            fill = type)) +\n      geom_bar(stat = \"identity\", position = \"dodge\") +\n      labs(fill = 'Type of shot')+\n      scale_y_continuous(limits = c(0, 100))\n    })\n    \n    # render the position specific plot\n    output$last_event_per_position <- renderPlot({\n      \n      selectedPosition <- input$select_position_last_event\n      if(is.null(selectedPosition)){selectedPosition = 1}\n      print(paste(\"selected position\", selectedPosition))\n      \n      eventDataOfPosition <- eventData[eventData$value3 == selectedPosition,] # filter by selected position\n      \n      # combine on player and type\n      eventDataOfPosition <-with(eventDataOfPosition,\n                                 aggregate(\n                                   list(\n                                     totalTaken = as.integer(value2),\n                                     totalMade = as.integer(value)\n                                   ),\n                                   list(\n                                     accountid = accountid,\n                                     firstname = firstname,\n                                     fullname = fullname,\n                                     type = value4\n                                   ),\n                                   sum\n                                 ))\n      # calc %\n      eventDataOfPosition$percentage <- ((eventDataOfPosition$totalMade/eventDataOfPosition$totalTaken)*100)\n      \n      #make plot\n      ggplot(eventDataOfPosition,\n             aes(x = fullname,\n                 y = percentage,\n                 fill = type)) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        geom_text(aes(label=round(percentage, digits = 0)), position = position_dodge(width = 0.9) ,vjust=2)+\n        labs(fill = 'Type of shot', x=\"Players\")+\n        theme(axis.text.x=element_text(angle = -45, hjust = 0))+\n        scale_y_continuous(limits = c(0, 100))\n    })\n    \n  }\n  \n  #Render the player info\n  renderPlayerInfo <- function(){\n    #Render the home layout for the current user.\n    output$player_home <- renderUI({\n      playerHomeLayout(currentUser)\n    })\n    \n    #Render the select dialog for the training sessions.\n    output$trainingSelectorOutput <- renderUI(\n      renderTrainingSelector(setNames(as.numeric(eventSubset$eventid),eventSubset$starttime))\n    )\n    \n    #Render the percentage text of the free throws\n    output$freeThrowPercentage <- renderText({\n      #Calculate the total made free throws of the training.\n      made  <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"free_throw\" ,]$value), na.rm = TRUE)\n      #Calculate the total taken free throws of the training.\n      taken <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"free_throw\", ]$value2), na.rm = TRUE)\n      #Calculate the percentage based on the made and taken shots.\n      percentage <- as.integer((made / taken) * 100)\n      #Print the actual percentage with the percentage sign to the text output.\n      paste(percentage, \"%\", sep = \"\")\n    })\n    \n    #Render the text below the percentage with the made and taken shots.\n    output$freeThrowCount <- renderText({\n      #Calculate the total taken free throws of the training.\n      takenshots <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"free_throw\", ]$value), na.rm = TRUE))\n      #Calculate the total made free throws of the training.\n      madeshots  <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"free_throw\" ,]$value2), na.rm = TRUE))\n      #Print the actual taken shots and the made shots with a slash sign between them to the text output.\n      paste(takenshots, \"/\", madeshots , sep = \"\")\n    })\n    \n    output$dribblePercentage <- renderText({\n      made  <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"dribble\" ,]$value), na.rm = TRUE)\n      taken <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"dribble\", ]$value2), na.rm = TRUE)\n      percentage <- as.integer((made / taken) * 100)\n      paste(percentage, \"%\", sep = \"\")\n    })\n    output$dribbleCount <- renderText({\n      takenshots <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"dribble\", ]$value), na.rm = TRUE))\n      madeshots  <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"dribble\" ,]$value2), na.rm = TRUE))\n      paste(takenshots, \"/\", madeshots , sep = \"\")\n    })\n    \n    output$catchThrowPercentage <- renderText({\n      made  <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"catch_throw\" ,]$value), na.rm = TRUE)\n      taken <- sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"catch_throw\", ]$value2), na.rm = TRUE)\n      percentage <- as.integer((made / taken) * 100)\n      paste(percentage, \"%\", sep = \"\")\n    })\n    output$catchThrowCount <- renderText({\n      takenshots <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"catch_throw\", ]$value), na.rm = TRUE))\n      madeshots  <- toString(sum(as.integer(eventSubset[eventSubset$eventid == input$trainingselector & eventSubset$value4 == \"catch_throw\" ,]$value2), na.rm = TRUE))\n      paste(takenshots, \"/\", madeshots , sep = \"\")\n    })\n    \n    output$home_graph_player <- renderPlot({\n      dataPlayerHomeGraph <- rsShotResult[rsShotResult$value4 == input$typeselectorHomeGraph, ]\n      dataPlayerHomeGraph[dataPlayerHomeGraph$accountid != currentUser$accountid,]$accountid <- 0\n      dataPlayerHomeGraph[dataPlayerHomeGraph$accountid != currentUser$accountid,]$fullname <- \"Team\"\n      \n      dataPlayerHomeGraph <-\n        with(dataPlayerHomeGraph,\n             aggregate(\n               list(\n                 totalTaken = as.integer(value2),\n                 totalMade = as.integer(value)\n               ),\n               list(\n                 accountid = accountid,\n                 fullname = fullname,\n                 eventid = eventid,\n                 eventdate = starttime\n               ),\n               sum\n             ))\n      dataPlayerHomeGraph$percentage <- (dataPlayerHomeGraph$totalMade/dataPlayerHomeGraph$totalTaken) *100\n      \n      ggplot(dataPlayerHomeGraph,\n             aes(x = eventdate,\n                 y = percentage,\n                 group = fullname)) +\n        geom_line((aes(color=fullname)))+ \n        geom_point((aes(color=fullname)), size=3)+\n        theme(axis.text.x=element_text(angle = -45, hjust = 0))+\n        scale_y_continuous(limits = c(0, 100))\n    })\n\n  }\n  \n  #RENDER THE ADMIN PAGE\n  renderAdmin <- function() {\n    query <- paste0(\n      \"exec GETTEAMLIST\"\n    )\n    sql <- sqlInterpolate(conn, query)\n    rs <- dbGetQuery(conn, sql)\n    \n    x <- setNames(as.numeric(rs$teamid), rs$teamcode)\n    \n    # Can use character(0) to remove all choices\n    if (is.null(x))\n      x <- character(0)\n    \n    output$admin_input <- renderUI({\n      adminUiLayout(x)\n    })\n  }\n  \n  renderPublicEvent <- function() {\n    print(paste(\"latest event: \", latestEventid))\n    query <- paste0(\n      \"exec GETLASTEVENT\"\n    )\n    sql <- sqlInterpolate(conn, query)\n    result <- dbGetQuery(conn, sql)\n    \n    print(result)\n    playersInEvent <<- result$accountid\n    x <- result$accountid\n    print(paste(\"playersInEvent\", playersInEvent))\n    print(paste(\"allplayers filtered met x: \", allPlayers[allPlayers$accountid %in% x, ]$firstname))\n    print(\"---\")\n    output$public_event <- renderUI({\n      publicEventUiLayout(playersInEvent)\n    })\n  }\n  \n  #RENDER THE HEATMAP PAGE\n  renderHeatMap <- function() {\n    output$heatmap_player <- renderUI({\n      heatmapUiLayout(eventsofPlayer)\n    })\n  }\n  \n  # coach analysis\n  renderAnalyses <- function(){\n    # make plot\n    output$shotAnalyse <- renderPlot({\n      print(input$shotAnalyseDate)\n      ggplot(rsShotResult[rsShotResult$fullname %in% input$shotAnalysePlayers\n                          &\n                            as.Date(rsShotResult$startdate) <= input$shotAnalyseDate[2]\n                          &\n                            as.Date(rsShotResult$startdate) >= input$shotAnalyseDate[1]\n                          &\n                            rsShotResult$value3 == input$shotAnalysePosition, ],\n             aes(x = starttime,\n                 y = percentage,\n                 fill = fullname)) +\n        geom_bar(stat = \"identity\", position = \"dodge\") +\n        labs(fill = 'Names')\n    })\n    \n    output$shotAnalyse2 <- renderPlot({\n      requestedPositions <- c()\n      \n      # add the positions to the requested positions\n      if (\"All\" %in% input$shotAnalyse2Position) {\n        requestedPositions <- c(requestedPositions, positionsAll)\n      }\n      if (\"Left\" %in% input$shotAnalyse2Position)  {\n        requestedPositions <- c(requestedPositions, positionsLeft)\n      }\n      if (\"Center\" %in% input$shotAnalyse2Position) {\n        requestedPositions <- c(requestedPositions, positionsCenter)\n      }\n      if (\"Right\" %in% input$shotAnalyse2Position) {\n        requestedPositions <- c(requestedPositions, positionsRight)\n      }\n      if (\"Inside circle\" %in% input$shotAnalyse2Position) {\n        requestedPositions <- c(requestedPositions, positionsInCircle)\n      }\n      if (\"Ouside Circle\" %in% input$shotAnalyse2Position) {\n        requestedPositions <- c(requestedPositions, positionsOutCircle)\n      }\n      \n      #select positions\n      resultsOfRequestedPositions <-\n        rsShotResult[rsShotResult$fullname %in% input$shotAnalyse2Players\n                     &\n                       as.Date(rsShotResult$starttime) <= input$shotAnalyse2Date[2]\n                     &\n                       as.Date(rsShotResult$starttime) >= input$shotAnalyse2Date[1]\n                     &\n                       rsShotResult$value3 %in% requestedPositions, ]\n      if (nrow(resultsOfRequestedPositions) >= 1) {\n        resultPerPosition <-\n          with(resultsOfRequestedPositions,\n               aggregate(\n                 list(\n                   totalTaken = as.integer(value2),\n                   totalMade = as.integer(value)\n                 ),\n                 list(\n                   accountid = accountid,\n                   fullname = fullname,\n                   eventid = eventid,\n                   eventdate = starttime\n                 ),\n                 sum\n               ))\n        # calculate percentage\n        resultPerPosition$percentage <-\n          ((\n            as.integer(resultPerPosition$totalMade) / as.integer(resultPerPosition$totalTaken)\n          ) * 100)\n        \n        print(resultPerPosition)\n        \n        ggplot(resultPerPosition,\n               aes(x = eventid,\n                   #x = as.Date(\n                   #      ISOdate(\n                   #        substr(eventdate,1,4),\n                   #        substr(eventdate,6,7),\n                   #        substr(eventdate,9,10)\n                   #      )\n                   #    ),\n                   y = percentage)) +\n          geom_line(aes(colour = as.character(accountid))) +\n          geom_point(aes(colour = as.character(accountid))) +\n          xlab(\"eventid\") +\n          scale_colour_manual(\n            values = palette(\"default\"),\n            name = \"Players\",\n            labels = resultPerPosition$fullname,\n            breaks = resultPerPosition$accountid\n          )\n      }\n      \n    })\n  }\n  \n  # render the heatmap\n  renderHeatmap <- function(){\n    output$heatMapPlayer <- renderPlot({\n      #make dataset\n      resultPerPosition <-\n        with(eventsOfPlayer, aggregate(\n          list(\n            totalTaken = as.integer(value2),\n            totalMade  = as.integer(value)\n          ),\n          list(\n            value3    = value3,\n            yearMonth = substr(starttime,1,7)\n          ),\n          sum\n        ))\n      print(resultPerPosition)\n      resultPerPosition$percentage <-\n        ((\n          as.integer(resultPerPosition$totalMade) / as.integer(resultPerPosition$totalTaken)\n        ) * 100) # calculate percentage\n      names(resultPerPosition)[1] <- \"positions\"# rename so it can be merged\n      resultPerPosition <-\n        merge(positionLocations, resultPerPosition, by = \"positions\") # merge with position locations\n      \n      resultPerPosition <- resultPerPosition[resultPerPosition$yearMonth == input$heatMapSlider,]\n      \n      resultPerPosition <-\n        resultPerPosition[rep(row.names(resultPerPosition),\n                              resultPerPosition$percentage),] # repeat amount of percentage to create heat on that point\n      print(resultPerPosition)\n      image <- png::readPNG(\"www/field.png\")\n      ggplot(resultPerPosition,\n             aes(x = locationX,\n                 y = locationY,\n                 fill = percentage)) +\n        guides(alpha = 0.4, size = FALSE) +\n        annotation_custom(rasterGrob(\n          image,\n          width = unit(1, \"npc\"),\n          height = unit(1, \"npc\")\n        ),-Inf,\n        Inf,\n        -Inf,\n        Inf) +\n        scale_fill_gradientn(\n          colors = c(\"steelblue\", \"blue\", \"hotpink\"),\n          labels = NULL,\n          name = \"\"\n        ) +\n        stat_density_2d(\n          geom = \"raster\",\n          aes(fill = ..density..),\n          alpha = 0.8,\n          contour = FALSE,\n          ylim = c(0, 100)\n        ) +\n        theme(\n          aspect.ratio = 0.673,\n          axis.title.x = element_blank(),\n          axis.text = element_blank(),\n          axis.ticks = element_blank()\n        ) +\n        coord_fixed(ylim = c(0, 100), xlim = c(0, 100)) +\n        xlim(c(-10, 110)) +\n        ylim(c(-10, 110)) +\n        labs(x = \"\", y = \"\", fill = \"\")\n    })\n  }\n  \n  # get all results\n  getShotResults <- function(x){\n    query <- paste0(\n      \"exec GETSHOTRESULTS\"\n    )\n    sql <- sqlInterpolate(conn, query)\n    rsShotResult <- dbGetQuery(conn, sql)\n  \n    # transform data\n    rsShotResult$startdate <- substring(rsShotResult$starttime, 1, 11)\n    rsShotResult$fullname <-\n      paste(rsShotResult$firstname, rsShotResult$lastname, sep = \" \")\n    rsShotResult$percentage <-\n      ((\n        as.integer(rsShotResult$value) / as.integer(rsShotResult$value2)\n      ) * 100)# calculate percentage\n    \n    #calculate made points\n    rsShotResult$points <-\n      ifelse(\n        rsShotResult$value3 %in% positionsInCircle,\n        (2 * as.integer(rsShotResult$value)),\n        ifelse(\n          rsShotResult$value3 %in% positionsOutCircle,\n          (3 * as.integer(rsShotResult$value)),\n          NA\n        )\n      )\n    \n    rsShotResult <<-\n      rsShotResult[rsShotResult$percentage <= 100,]#filter only viable percentage\n  }\n})\n",
    "created" : 1517563957347.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2463425950",
    "id" : "BD20FFD0",
    "lastKnownWriteTime" : 1517469380,
    "last_content_update" : 1517469380,
    "path" : "C:/Users/poden/surfdrive/04 CTOBasketbal/basketball_1718/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}